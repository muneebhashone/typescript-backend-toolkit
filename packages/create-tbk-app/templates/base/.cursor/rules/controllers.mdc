---
globs: *.controller.ts
description: Controller patterns for handling business logic
---

# Controller Patterns

## Core Principle

Controllers are async functions that handle validated requests and return responses. They should be thin - delegate complex logic to services.

## Controller Template

```typescript
import type { Request } from 'express';
import type { ResponseExtended } from '@/types';
import type {
  CreateItemSchemaType,
  GetItemsSchemaType,
  UpdateItemSchemaType,
  CreateItemResponseSchema,
  GetItemByIdResponseSchema,
  GetItemsResponseSchema,
  UpdateItemResponseSchema,
} from './module.schema';
import {
  createItem,
  deleteItem,
  findById,
  getItems,
  updateItem,
} from './module.service';

/**
 * Create new item
 */
export const handleCreate = async (
  req: Request<unknown, unknown, CreateItemSchemaType>,
  res: ResponseExtended<CreateItemResponseSchema>,
) => {
  // 1. Extract validated data (already validated by Zod middleware)
  const data = req.body;

  // 2. Access JWT payload (if route uses canAccess middleware)
  const userId = req.user?.sub;

  // 3. Call service layer for business logic
  const item = await createItem({ ...data, createdBy: userId });

  // 4. Return typed response
  return res.created?.({
    success: true,
    message: 'Item created successfully',
    data: item,
  });
};

/**
 * Get single item by ID
 */
export const handleGetById = async (
  req: Request<{ id: string }, unknown, unknown>,
  res: ResponseExtended<GetItemByIdResponseSchema>,
) => {
  const { id } = req.params;

  const item = await findById(id);

  if (!item) {
    return res.notFound?.({
      success: false,
      message: 'Item not found',
    });
  }

  return res.ok?.({
    success: true,
    data: item,
  });
};

/**
 * Get paginated list of items
 */
export const handleGetItems = async (
  req: Request<unknown, unknown, unknown, GetItemsSchemaType>,
  res: ResponseExtended<GetItemsResponseSchema>,
) => {
  const { results, paginatorInfo } = await getItems(req.query);

  return res.ok?.({
    success: true,
    data: {
      items: results,
      paginator: paginatorInfo,
    },
  });
};

/**
 * Update existing item
 */
export const handleUpdate = async (
  req: Request<{ id: string }, unknown, UpdateItemSchemaType>,
  res: ResponseExtended<UpdateItemResponseSchema>,
) => {
  const { id } = req.params;
  const data = req.body;
  const userId = req.user?.sub;

  const item = await updateItem(id, data, userId);

  if (!item) {
    return res.notFound?.({
      success: false,
      message: 'Item not found',
    });
  }

  return res.ok?.({
    success: true,
    message: 'Item updated successfully',
    data: item,
  });
};

/**
 * Delete item
 */
export const handleDelete = async (
  req: Request<{ id: string }, unknown, unknown>,
  res: ResponseExtended<Record<string, never>>,
) => {
  const { id } = req.params;

  await deleteItem(id);

  return res.ok?.({
    success: true,
    message: 'Item deleted successfully',
  });
};
```

## Key Points

### TypeScript Request Typing

Always use TypeScript generics for type-safe requests:

```typescript
Request<ParamsType, unknown, BodyType, QueryType>;

// Examples:
Request<{ id: string }, unknown, unknown>; // params only
Request<unknown, unknown, CreateUserSchemaType>; // body only
Request<unknown, unknown, unknown, GetUsersSchemaType>; // query only
Request<{ id: string }, unknown, UpdateUserSchemaType>; // params + body
```

### Request Data Access

- `req.body` - Request body (validated by Zod)
- `req.params` - URL parameters (validated by Zod)
- `req.query` - Query parameters (validated by Zod)
- `req.user` - JWT token payload (if using extractJwt middleware)

### JWT Payload Access

When route uses `extractJwt` middleware from [extract-jwt.ts](mdc:src/middlewares/extract-jwt.ts):

```typescript
import type { JwtPayload } from '@/utils/jwt.utils';

// Access JWT payload via req.user
const userId = req.user?.sub; // User ID
const email = req.user?.email; // User email
const username = req.user?.username; // Username
const role = req.user?.role; // User role

// Type assertion if needed
const payload = req.user as JwtPayload;
```

**JwtPayload Type:**

```typescript
type JwtPayload = {
  sub: string; // User ID
  email?: string | null;
  phoneNo?: string | null;
  username: string;
  role: RoleType;
};
```

### Response Pattern (RECOMMENDED)

Use `ResponseExtended` typed response helpers for all controllers:

```typescript
import type { ResponseExtended } from '@/types';
import type { CreateItemResponseSchema } from './module.schema';

export const handleCreate = async (
  req: Request<unknown, unknown, CreateItemSchemaType>,
  res: ResponseExtended<CreateItemResponseSchema>,
) => {
  const item = await createItem(req.body);

  // 201 Created response
  return res.created?.({
    success: true,
    message: 'Item created',
    data: item,
  });
};
```

**Available Response Methods:**

```typescript
// 200 OK - Success response
return res.ok?.({
  success: true,
  message: 'Success message',
  data: item,
});

// 201 Created - Resource created
return res.created?.({
  success: true,
  message: 'Item created',
  data: newItem,
});

// 204 No Content - Successful deletion
return res.noContent?.();

// 404 Not Found - Resource not found
return res.notFound?.({
  success: false,
  message: 'Item not found',
});

// 400 Bad Request - Invalid input
return res.badRequest?.({
  success: false,
  message: 'Invalid data',
});

// Paginated list response
return res.ok?.({
  success: true,
  data: {
    items: results,
    paginator: paginatorInfo,
  },
});
```

**Benefits:**

- ✅ Type-safe response structure
- ✅ Runtime validation (configurable via `RESPONSE_VALIDATION` env var)
- ✅ Accurate OpenAPI documentation
- ✅ Consistent response format across your API
- ✅ Better IDE autocomplete and error detection

**Standard Response Format:**

```json
{
  "success": true,
  "message": "Optional message",
  "data": {
    /* Optional payload */
  }
}
```

### Cookie Management

For authentication tokens:

```typescript
import { AUTH_COOKIE_KEY, COOKIE_CONFIG } from './auth.constants';

// Set auth cookie
res.cookie(AUTH_COOKIE_KEY, token, COOKIE_CONFIG);

// Clear cookie on logout
res.cookie(AUTH_COOKIE_KEY, undefined, COOKIE_CONFIG);
```

### Error Handling

Controllers have two options for handling errors:

**Option 1: Return typed error responses (RECOMMENDED)**

```typescript
const item = await findById(id);

if (!item) {
  return res.notFound?.({
    success: false,
    message: 'Item not found',
  });
}

if (!hasPermission) {
  return res.forbidden?.({
    success: false,
    message: 'Access denied',
  });
}
```

**Option 2: Let global error handler catch thrown errors**

```typescript
// Services throw errors, global handler catches them
const item = await findById(id); // Throws if not found

// Or throw explicit errors
throw new Error('Something went wrong'); // 500 error

// Throw with custom status code
const error = new Error('Forbidden') as any;
error.statusCode = 403;
throw error;
```

**When to use each:**
- Use **typed responses** when you need specific HTTP status codes and error messages
- Use **throwing errors** for unexpected failures or service-level errors
- Controllers don't need try-catch blocks - global error handler in [error-handler.ts](mdc:src/middlewares/error-handler.ts) catches all

### Status Codes

Use `@/plugins/magic/status-codes` for type-safe status codes:

```typescript
import { StatusCodes } from '@/plugins/magic/status-codes';

StatusCodes.OK; // 200
StatusCodes.CREATED; // 201
StatusCodes.BAD_REQUEST; // 400
StatusCodes.UNAUTHORIZED; // 401
StatusCodes.FORBIDDEN; // 403
StatusCodes.NOT_FOUND; // 404
StatusCodes.INTERNAL_SERVER_ERROR; // 500
```

### Logging

Use Pino logger from [logger.ts](mdc:src/plugins/observability/logger.ts):

```typescript
import logger from '@/plugins/observability/logger';

logger.info('Action performed', { userId, action: 'create' });
logger.error('Error occurred', { error: error.message, userId });
logger.warn('Warning message', { data });
```

## Service Layer Pattern

Controllers should delegate to services in `module.service.ts`:

- **Controllers**: Handle HTTP concerns (req/res, cookies, response formatting)
- **Services**: Handle business logic, database operations, external APIs

Import individual service functions:

```typescript
// ✅ DO: Import specific functions
import { createUser, deleteUser, getUsers } from './user.service';

// ❌ DON'T: Use namespace imports
import * as userService from './user.service';
```

## Naming Conventions

- Controller functions: `handle` + `PascalCase` action
  - `handleGetUsers`
  - `handleCreateUser`
  - `handleDeleteUser`
  - `handleLoginByEmail`
  - `handleGetCurrentUser`

## Real-World Examples

### Authentication Controller

```typescript
export const handleLoginByEmail = async (
  req: Request<unknown, unknown, LoginUserByEmailSchemaType>,
  res: ResponseExtended<LoginResponseSchema>,
) => {
  const token = await loginUserByEmail(req.body);

  if (config.SET_SESSION) {
    res.cookie(AUTH_COOKIE_KEY, token, COOKIE_CONFIG);
  }

  return res.ok?.({
    success: true,
    message: 'Login successful',
    data: { token },
  });
};

export const handleLogout = async (
  _: Request,
  res: ResponseExtended<Record<string, never>>,
) => {
  res.cookie(AUTH_COOKIE_KEY, undefined, COOKIE_CONFIG);

  return res.ok?.({
    success: true,
    message: 'Logout successful',
  });
};
```

### Protected Route with JWT

```typescript
export const handleChangePassword = async (
  req: Request<unknown, unknown, ChangePasswordSchemaType>,
  res: ResponseExtended<Record<string, never>>,
) => {
  const userId = req.user?.sub;

  await changePassword(userId, req.body);

  return res.ok?.({
    success: true,
    message: 'Password successfully changed',
  });
};
```

### Paginated List

```typescript
export const handleGetUsers = async (
  req: Request<unknown, unknown, unknown, GetUsersSchemaType>,
  res: ResponseExtended<GetUsersResponseSchema>,
) => {
  const userId = req.user?.sub;

  const { results, paginatorInfo } = await getUsers(
    { id: userId },
    req.query,
  );

  return res.ok?.({
    success: true,
    data: {
      items: results,
      paginator: paginatorInfo,
    },
  });
};
```

## Common Mistakes to Avoid

❌ DON'T use direct `res.status().json()`
✅ DO use `ResponseExtended` typed helpers (`res.ok?.()`, `res.created?.()`, etc.)

❌ DON'T cast JWT payload with `as JwtPayload`
✅ DO use optional chaining `req.user?.sub`

❌ DON'T put business logic in controllers
✅ DO move complex logic to services

❌ DON'T validate data in controllers (Zod does this)
✅ DO trust validated data from req.body/params/query

❌ DON'T use try-catch everywhere
✅ DO let global error handler catch errors OR use typed error responses

❌ DON'T send multiple responses
✅ DO return single response per request

❌ DON'T use namespace imports for services
✅ DO import individual service functions

❌ DON'T forget response type in controller signature
✅ DO type with `ResponseExtended<YourResponseSchema>`
