---
globs: *.router.ts,*.routes.ts
description: Routing patterns using MagicRouter for automatic OpenAPI generation
---

# Routing with MagicRouter

## Core Principle

NEVER use plain Express routing. ALWAYS use MagicRouter from [router.ts](mdc:src/plugins/magic/router.ts).

## Pattern Template

```typescript
import MagicRouter from '@/plugins/magic/router';
import { canAccess } from '@/middlewares/can-access';
import {
  handleAction,
  handleGetById,
  handleCreate,
  handleSearch,
} from './module.controller';
import {
  actionSchema,
  createSchema,
  idParamsSchema,
  searchQuerySchema,
  actionResponseSchema,
  getMeResponseSchema,
  createItemResponseSchema,
  getItemByIdResponseSchema,
  searchItemsResponseSchema,
} from './module.schema';

export const MODULE_ROUTER_ROOT = '/module';

const moduleRouter = new MagicRouter(MODULE_ROUTER_ROOT);

// Public route with schema validation and response config
moduleRouter.post(
  '/action',
  {
    requestType: { body: actionSchema },
    responses: {
      200: actionResponseSchema,
    },
  },
  handleAction,
);

// Protected route with authentication
moduleRouter.get(
  '/me',
  {
    responses: {
      200: getMeResponseSchema,
    },
  },
  canAccess(),
  handleGetById,
);

// Protected route with schema, auth, and response config
moduleRouter.post(
  '/create',
  {
    requestType: { body: createSchema },
    responses: {
      201: createItemResponseSchema,
    },
  },
  canAccess(),
  handleCreate,
);

// Route with params
moduleRouter.get(
  '/:id',
  {
    requestType: { params: idParamsSchema },
    responses: {
      200: getItemByIdResponseSchema,
    },
  },
  handleGetById,
);

// Route with query params (paginated)
moduleRouter.get(
  '/search',
  {
    requestType: { query: searchQuerySchema },
    responses: {
      200: searchItemsResponseSchema,
    },
  },
  handleSearch,
);

export default moduleRouter.getRouter();
```

## MagicRouter API

### Router Instantiation

```typescript
const router = new MagicRouter(ROUTER_ROOT);
```

- Create router instance with root path (e.g., `/auth`, `/user`)
- Root path used for route grouping and OpenAPI tag generation

### Route Definition Signature

```typescript
router.method(path, requestType, ...handlers);
```

**Parameters:**

1. `path`: Route path string (e.g., `/login`, `/:id`)
2. `requestType`: Schema configuration object
3. `...handlers`: Middleware functions and controller (spread arguments)

### Request Type Object

```typescript
{
  requestType?: {
    body?: ZodSchema,      // Request body validation
    params?: ZodSchema,    // URL params validation
    query?: ZodSchema,     // Query string validation
  },
  responses?: {            // NEW: Response schemas per status code
    200?: ResponseSchema,  // Success response
    201?: ResponseSchema,  // Created response
    404?: ResponseSchema,  // Not found response
    // ... other status codes
  },
  contentType?: string,    // 'application/json' | 'multipart/form-data' | etc.
}
```

- Use empty object `{}` when no validation needed
- Can combine `body`, `params`, and `query` in same route
- **NEW**: Add `responses` object for response schemas (RECOMMENDED)

### Response Configuration (NEW - RECOMMENDED)

**BEST PRACTICE:** Define response schemas in your schema file and import them:

```typescript
// In module.schema.ts
import { R } from '@/plugins/magic/response.builders';
import { itemOutSchema } from './module.dto';

export const createItemResponseSchema = R.success(itemOutSchema);
export const getItemsResponseSchema = R.paginated(itemOutSchema);

export type CreateItemResponseSchema = z.infer<typeof createItemResponseSchema>;
export type GetItemsResponseSchema = z.infer<typeof getItemsResponseSchema>;

// In module.router.ts
import { createItemResponseSchema, getItemsResponseSchema } from './module.schema';

responses: { 201: createItemResponseSchema }
responses: { 200: getItemsResponseSchema }
```

**Alternative (inline):** Use response builders directly in router:

```typescript
import { R } from '@/plugins/magic/response.builders';

// Standard success response
responses: { 200: R.success(itemSchema) }

// Paginated list response
responses: { 200: R.paginated(itemSchema) }

// Created response
responses: { 201: R.success(itemSchema) }

// No content response
responses: { 204: R.noContent() }

// Error response
responses: { 404: R.error() }

// Multiple status codes
responses: {
  200: R.success(itemSchema),
  404: R.error(),
}

// Raw response (non-envelope)
responses: { 200: R.raw(customSchema) }
```

**Response Builders:**

- `R.success(schema)` - Standard envelope: `{ success, message?, data? }`
- `R.paginated(itemSchema)` - Paginated list: `{ success, message?, data: { items, paginator } }`
- `R.noContent()` - Empty 204 response
- `R.error(schema?)` - Error envelope (optional custom schema)
- `R.raw(schema)` - Non-envelope response (e.g., healthcheck)

**Why define in schema files?**

- ✅ Type-safe controller responses with `ResponseExtended<T>`
- ✅ Centralized response definitions
- ✅ Easier to maintain and update
- ✅ Better code organization

### Handler Order

The last handler in the spread is treated as the **controller**. All preceding handlers are **middleware**.

```typescript
// Public route
router.post('/action', { requestType: { body: schema } }, controller);

// With one middleware
router.get('/me', {}, canAccess(), controller);

// With multiple middleware
router.post('/upload', {}, middleware1(), middleware2(), controller);
```

## Authentication

### Public Routes

No authentication required - just pass the controller:

```typescript
router.post('/login', { requestType: { body: loginSchema } }, handleLogin);
```

### Protected Routes

Add `canAccess()` middleware before the controller:

```typescript
import { canAccess } from '@/middlewares/can-access';

router.get('/me', {}, canAccess(), handleGetCurrentUser);
```

- Security is auto-detected in OpenAPI by presence of `canAccess()` middleware
- JWT payload available as `req.user` in controller (via `canAccess()`)
- Access payload with optional chaining: `req.user?.sub`, `req.user?.email`

## Common Route Patterns

### Body Validation

```typescript
router.post('/create', { requestType: { body: createSchema } }, handleCreate);
```

### Params Validation

```typescript
router.get('/:id', { requestType: { params: idParamsSchema } }, handleGetById);
```

### Query Validation

```typescript
router.get(
  '/search',
  { requestType: { query: searchQuerySchema } },
  handleSearch,
);
```

### Combined Validation

```typescript
router.put(
  '/:id',
  {
    requestType: {
      params: idParamsSchema,
      body: updateSchema,
    },
  },
  canAccess(),
  handleUpdate,
);
```

### No Validation

```typescript
router.post('/logout', {}, handleLogout);
```

## File Uploads

### Route Configuration

Enable multipart form-data handling in route config:

```typescript
import { uploadSchema, uploadResponseSchema } from './upload.schema';

router.post(
  '/upload',
  {
    requestType: { body: uploadSchema },
    contentType: 'multipart/form-data',
    multipart: true,
    responses: {
      201: uploadResponseSchema,
    },
  },
  canAccess(),
  handleUpload,
);
```

### Schema Definition

Use `zFile()` and `zFiles()` helpers with validation options:

```typescript
import { z } from 'zod';
import { zFile, zFiles, MIME_GROUPS } from '@/plugins/magic/zod-extend';
import { R } from '@/plugins/magic/response.builders';

// Define upload schema with file validation
export const uploadSchema = z.object({
  avatar: zFile({
    maxSize: 5 * 1024 * 1024, // 5MB
    allowedTypes: MIME_GROUPS.IMAGES, // ['image/jpeg', 'image/jpg', 'image/png', 'image/webp']
  }),
  multipleFiles: zFiles({
    maxSize: 2 * 1024 * 1024, // 2MB per file
    allowedTypes: MIME_GROUPS.IMAGES,
  }).optional(),
});

// Define response schema
export const uploadResponseSchema = R.success(
  z.object({
    key: zFile(),
    multipleFiles: zFiles().optional(),
  }),
);

export type UploadSchema = z.infer<typeof uploadSchema>;
export type UploadResponseSchema = z.infer<typeof uploadResponseSchema>;
```

### Controller Implementation

Access files through `req.body` (not `req.file` or `req.files`):

```typescript
import type { Request } from 'express';
import { uploadFile } from '@/lib/storage';
import type { ResponseExtended } from '@/types';
import { errorResponse } from '@/utils/response.utils';
import { UploadSchema, UploadResponseSchema } from './upload.schema';

export const handleUpload = async (
  req: Request<null, null, UploadSchema>,
  res: ResponseExtended<UploadResponseSchema>,
) => {
  try {
    const avatar = req.body.avatar; // Single file
    const multipleFiles = req.body.multipleFiles; // Multiple files (optional)

    if (!avatar) {
      return errorResponse(res, 'File not uploaded');
    }

    // Upload to S3
    const key = `uploads/${avatar.originalFilename}`;
    const { url } = await uploadFile({ file: avatar, key });

    return res.created?.({
      success: true,
      message: 'File uploaded successfully',
      data: {
        key: avatar,
        multipleFiles,
      },
    });
  } catch (err) {
    return errorResponse(res, (err as Error).message);
  }
};
```

### File Validation Options

**Available MIME_GROUPS:**
- `MIME_GROUPS.IMAGES` - jpeg, jpg, png, webp
- `MIME_GROUPS.IMAGES_WITH_GIF` - jpeg, jpg, png, gif, webp
- `MIME_GROUPS.DOCUMENTS` - pdf, doc, docx
- `MIME_GROUPS.SPREADSHEETS` - xls, xlsx, csv

**zFile() options:**
- `maxSize`: Maximum file size in bytes
- `allowedTypes`: Array of allowed MIME types (string[] or MIME_GROUPS)

**File object properties:**
- `file.filepath`: Temporary file path on disk
- `file.size`: File size in bytes
- `file.mimetype`: MIME type string
- `file.originalFilename`: Original filename from upload

## Available HTTP Methods

- `router.get()`
- `router.post()`
- `router.put()`
- `router.patch()`
- `router.delete()`

## Route Organization

### File Structure

```
module/
  ├── module.controller.ts  # Export named controller functions
  ├── module.router.ts      # Define routes
  ├── module.schema.ts      # Zod schemas
  ├── module.service.ts     # Business logic
  └── module.model.ts       # Database models
```

### Router Export Pattern

```typescript
export const MODULE_ROUTER_ROOT = '/module';
const moduleRouter = new MagicRouter(MODULE_ROUTER_ROOT);

// ... define routes ...

export default moduleRouter.getRouter();
```

### Register in Routes

Add router to [routes.ts](mdc:src/routes/routes.ts):

```typescript
import moduleRouter from './modules/module/module.router';

app.use(moduleRouter);
```

## OpenAPI Generation

MagicRouter automatically generates OpenAPI documentation:

- **Tags**: Auto-generated from router root path
- **Summary**: Auto-generated from controller function name
- **Security**: Auto-detected from `canAccess()` middleware
- **Schemas**: Generated from Zod schemas in `requestType`
- **Responses**: Per-status schemas from `responses` config (NEW)
  - If `responses` provided: Uses your schemas per status code
  - If not provided: Defaults to 200, 400, 404, 500
  - Default errors (400/404/500) added unless overridden

## Common Mistakes to Avoid

❌ **DON'T** use plain Express routing

```typescript
router.get('/path', handler); // Wrong
```

✅ **DO** use MagicRouter signature

```typescript
router.get('/path', {}, handler); // Correct
```

❌ **DON'T** forget the request type object

```typescript
router.post('/create', handleCreate); // Wrong
```

✅ **DO** always include it (use `{}` if no validation)

```typescript
router.post('/create', {}, handleCreate); // Correct
```

❌ **DON'T** use array syntax for handlers

```typescript
router.get('/me', {}, [canAccess(), handler]); // Wrong
```

✅ **DO** use spread arguments

```typescript
router.get('/me', {}, canAccess(), handler); // Correct
```

❌ **DON'T** forget to call `.getRouter()`

```typescript
export default moduleRouter; // Wrong
```

✅ **DO** call `.getRouter()` on export

```typescript
export default moduleRouter.getRouter(); // Correct
```

❌ **DON'T** use wrong schema object structure

```typescript
{
  schema: bodySchema;
} // Wrong
{
  body: bodySchema;
} // Wrong
```

✅ **DO** use correct nesting

```typescript
{
  requestType: {
    body: bodySchema;
  }
} // Correct
```
